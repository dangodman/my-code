# 自我介绍
姓名 + 学校 + 做过什么 + 有过什么成绩 + 为什么能胜任

# 1. 数组上的方法,在js中的意义
var a = []
a.push()
a.pop()

1. 创建对象字面量在v8的执行过程中相当于 new了一个构造函数,通常我们不去直接new构造函数，因为不够简洁直观
2. 因为a相当于 new Array() 得到的，那么a的隐式原型(__proto__) === Array.prototype,V8在查找属性的时候,会先在对象上查找，找不到就会顺着对象的原型往上查找 

3. new 的过程干了什么
  1. 创建一个对象
  2. 将该对象的隐式原型指向构造函数的显式原型
  3. 将构造函数的this指向对象，使对象获得构造函数的属性和方法
  4. 返归这个对象

# 2.promise有几种状态? 可以重复改变吗？
  1. 3种: Pending Fulfilled Rejected

  - 红绿灯算法
    
# 3. 输出结果

# 4. 聊聊你对语义化的理解
  - 有哪些:header nav aside article section footer

  - 优点: 可读性好，搜索引擎优化，更好地支持各种终端

# 5. 斐波那契


# 6. 用过什么AI工具
 1. chatGpt (刻意练习prompt技巧,生成简单的前端网页,学习) 
 2. Copilot 提升开发效率
 3. 最近在学习transformer, openai技能,对大模型很感兴趣,也在学习LangChain, LLM
 4. 自己准备一个大模型，介绍你对他的理解·


# 7. 讲讲HTTP请求的三次握手
  - 三次握手是TCP协议建立连接时产生的
  1. 客户端发送连接请求到服务端,客户端状态进入 SYN-SENT状态
  2. 服务端接受到了请求连接报文后，返回一个应答(包含ACK序号),服务端进入 SYN-RECEIVED状态
  3. 客户端接收到了同意连接的应答后，还要向服务端发送一个确认收到的报文。再进入ESTABLISHED状态

  - 为什么一定要三次握手，两次行不行
  不行，假设客户端给服务端发送了一个建立请求A,但是因为网络环境差，这个请求A超时了，那么TCP会启动超时重传机制，再发送一个新的建立连接B，服务端接受到B请求后应答，如果此时就完成了建立连接的话，当客户端和服务端通信完成后，便释放了连接，对方都进入Close状态，假设此时A请求又抵达了服务端，那么服务端会认为客户端又要建立新的链接从而应答该请求并进入ESTABLISHED状态，而此刻客户端是Close状态，那么服务端就会一直等待，造成资源浪费。


  - 四次挥手
  1. 客户端A认为数据发送完成，向服务端B发送释放连接请求
  2. B收到释放连接请求后，返回一个ACK报文，并进入CLOSE-WAIT状态，此时不在接受A发送的数据，但是B仍然可以给A发送数据
  3. B如果此时还没有发完的数据，就会继续发送，发完后向A发送释放连接的请求，B进入到LAST-ACK状态
  4. A收到释放连接的请求，向B发送应答，进入CLOSED状态，B接受到该应答也进入CLOSED状态

# 说一说跨域
https://192.168.31.45:8080/user

协议号:域名：端口号 / 路径

- 同源策略: 协议号-域名-端口号 都相同的地址，浏览器才认为是同源

- 跨域：后端返回给浏览器的数据会被浏览器的同源策略给拦截下来

- 同源策略的目的是数据安全


## 解决跨域 (开发阶段好调试)
  http://192.168.31.1:8080 (前端vue)

  http://192.168.31.2:8080 (后端go)

  1. JSONP  -- 借助script标签上的src属性不受同源策略的影响这一机制，来实现跨域
   - ajax请求受同源策略的影响，但是<script>上的src属性不受同源策略的影响，且该属性也会导致浏览器发送一个请求

   原理：
     1. 借助script的src属性给后端发送一个请求，且携带一个参数('callback')
     2. 前端在window对象上添加了一个callback函数
     3. 后端接受到这个 'callback' 后，将要返回给前端的数据data和这个参数callback进行拼接成callback(data),并返回
     4. 因为window上已经有一个callback函数，后端又返回了一个形如callback(data)，浏览器会将该字符串执行成callback的调用
     
   缺点：1. 必须要后端配合 2. 只能用于get请求